#+TITLE: Accounting Receipts Helper

In order to simplify monthly reporting of receipts and invoices to my accountant, I've written a series of functions that help me in marking emails with invoices or receipts, collecting the needed assets and compiling the deliverables to the accountant. These scripts minimize a fair amount of toil.

* Conventions

For convenience (brevity, rather) we're not going to use =accounting-receipts-helper= as a prefix but will use =acct-rcpt= instead.

* TODO Manage Accounting Context

Since it is likely that one needs to maintain contexts for multiple organizations, the user should be able to define these contexts and switch between them whenever necessary.

#+begin_src elisp :tangle acct-rcpt.el
(defcustom acct-rcpt-contexts '()
"Accounting contexts"
:type 'sexp
:group 'acct-rcpt)
#+end_src

** TODO Define format for contexts

#+begin_src elisp
(let ((contexts '(("Acme Corp"
                   (:base-directory "/tmp/fin/Acme Corp"))
                  ("Muster GmbH"
                   (:base-directory "/tmp/fin/Muster GmbH"))
                  ("Voorbeeld BV"
                   (:base-directory "/tmp/blah/voorbeeld-bv")))))
  (assoc "Voorbeeld BV" contexts))
#+end_src

#+begin_src elisp :results none
(defun acct-rcpt--validate-context-body (context-body))
#+end_src

*** Context Validation

A /context/ is:
1. a list consistent of 2 elements, /name/ and /body/
2. where /name/ is an alphanumeric string
3. where /body/ is an alist containing
   - =:base-directory= a string containing a path to the directory of the context

**** Context Label Validation

In order to validate context labels, we define *valid context label* function to return a 2-element list containing a valid label or =nil= as its first element and an optional string indicating the grounds on which validation failed after verifying that:
1. input is a string
2. trimmed string, i.e.: with leading and trailing whitespace removed, is of a nonzero length

Our *valid context label* helper returns a /tuple/ of a string value and an error message which can be of the following form:
- ~(nil ERROR)~, when the input was invalid where =ERROR= is a string detailing the problem
- ~(STRING nil)~, when the input was valid and =STRING= is the cleaned-up version of the input for further use.

#+begin_src elisp :results none
(defun acct-rcpt--valid-context-label (label)
  (cond ((not (stringp label))
         '(nil "Label is not a string"))
        ((= (length (string-clean-whitespace label)) 0)
         '(nil "Stripped label is not of nonzero length"))
        (t (list (string-clean-whitespace label) nil))))
#+end_src

The tests confirm that typechecking (.e.g.: input is of type string) and whitespace trimming work as expected. In order to minimize repetition, the =agree= helper is defined to verify agreement between an expected value and the output of the *valid context label* helper.

#+begin_src elisp :results none
(ert-deftest acct-rcpt--valid-context-label ()
  (let ((agree (lambda (x y)
                 (equal x (car (acct-rcpt--valid-context-label y))))))
    (should (funcall agree nil 'two))
    (should (funcall agree nil 12))
    (should (funcall agree nil t))
    (should (funcall agree nil " "))
    (should (funcall agree "Info" "Info "))
    (should (funcall agree "$-sign" "$-sign"))
    (should (funcall agree "Hi-Tech Corp" "  Hi-Tech Corp  "))
    (should (funcall agree "Hüçø Co" "Hüçø Co"))))
#+end_src

**** Context Data Validation

In order to valildate context data, we define a *valid context data* function to return a 2-element list containing a valid context data alist or =nil= as its first element and an optional string indicating the grounds on which validation failed after verifying that:
1. input is an alist (association list)
2. input alist has the =:base-directory= key with a /string/ value

#+begin_src elisp :results none
(defun acct-rcpt--valid-context-data (data)
  (cond ((not (and (listp data) (cl-every 'consp data)))
         '(nil "Context data is not a valid alist"))
        ((not (stringp (alist-get :base-directory data)))
         '(nil "Context data lacks :base-directory key with a string value"))
        (t (list data nil))))
#+end_src

The tests confirm that "typechecking" (i.e.: input is an alist) and schema validation (structure) work as expected. As in the [[*Context Label Validation][label validation helper]], we define an =agree= helper to verify agreement between an expected value and the output of the *valid context label* helper.

#+begin_src elisp :results none
(ert-deftest acct-rcpt--valid-context-data ()
  (let ((agree (lambda (x y)
                 (equal x (car (acct-rcpt--valid-context-data y)))))
        (dummy '((:base-directory . "/tmp/nice"))))
    (should (funcall agree nil " "))
    (should (funcall agree nil '()))
    (should (funcall agree nil '(:base-directory)))
    (should (funcall agree nil '(:base-directory . "")))
    (should (funcall agree nil '(:base-directory "hi")))
    (should (funcall agree nil '((:base-directory "/tmp/nice"))))
    (should (funcall agree dummy dummy))
    (should (funcall agree nil '((:base-directory . :path))))
    (should (funcall agree nil '((:base-directory))))))
#+end_src

#+begin_src elisp :results none

(defun acct-rcpt--valid-context-data (context)
  "Validate a context"
  (let ((validate-length (lambda (x) (eq (length x) 2)))
        (validate-name acct-rcpt--valid-label-p)
        (validate-data (lambda (x) t)))
    (cond ((not (funcall validate-length context)) nil)
          ((not (acct-rcpt--valid-label-p context)) nil)
          ((not (funcall validate-data context)) nil)
          (t))))
#+end_src

#+begin_src elisp :results none
(ert-deftest acct-rcpt--valid-context-p ()
  (let ((context-list '("Acme Corp" (:base-directory "/tmp/acme")))
        (context-name-empty '("" (:base-directory "/tmp/acme")))
        (context-data-only '((:base-directory "/tmp/acme")))
        (context-name-only '("Acme Corp"))
        (empty-list '()))
    (should (eq (acct-rcpt--valid-context-p context-list) t))
    (should (eq (acct-rcpt--valid-context-p context-name-empty) t))
    (should (eq (acct-rcpt--valid-context-p context-data-only) t))
    (should (eq (acct-rcpt--valid-context-p context-name-only) nil))))
#+end_src

#+begin_src elisp :results none
(defun acct-rcpt--validate-contexts (contexts)
  (message (format "CONTEXTS %S and %S" (car contexts)))
  (cl-every (lambda (x) (eq x x)) (seq-map (lambda (x) t) contexts)))
#+end_src

#+begin_src elisp :results none
(ert-deftest acct-rcpt--validate-contexts ()
  "Validate the structure of the contexts"
  (let ((valid-contexts '(("Acme Corp"
                          (:base-directory "/tmp/fin/Acme Corp"))
                         ("Muster GmbH"
                          (:base-directory "/tmp/fin/Muster GmbH"))
                         ("Voorbeeld BV"
                          (:base-directory "/tmp/blah/voorbeeld-bv")))))
    (should (equal (acct-rcpt--validate-contexts valid-contexts) t))))
#+end_src

** TODO Define more specific type for contexts

* TODO Create Directory

#+begin_src elisp :tangle acct-rcpt.el

#+end_src

* TODO Collect Artifacts (Receipts and Invoices)
* TODO Review Collection
* TODO Send Collection
